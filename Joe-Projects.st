Array variableSubclass: #ThreeDimArray	instanceVariableNames: 'xDim yDim zDim list arrays cubeFilled'	classVariableNames: ''	poolDictionaries: ''	category: 'Joe-Projects'!!ThreeDimArray methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 16:46'!setUpArrays	1 to: xDim do: [ :x | 		self at: x put: (Array new: yDim).		1 to: yDim do: [ :y | 			(self at: x) at: y put: (Array new: zDim). ]. ].! !!ThreeDimArray methodsFor: 'accessors' stamp: 'joejohnston 11/3/2013 10:26'!atX: xNum atY: yNum atZ: zNum	^ ((self at: xNum) at: yNum) at: zNum.! !!ThreeDimArray methodsFor: 'accessors' stamp: 'joejohnston 11/9/2013 16:30'!atX: xNum atY: yNum atZ: zNum put: anObject	((self at: xNum) at: yNum) at: zNum put: anObject.	self list add: anObject -> (Array with: xNum with: yNum with: zNum).! !!ThreeDimArray methodsFor: 'accessors' stamp: 'joejohnston 11/2/2013 15:49'!dimesnions	^#(xDim yDim zDim)! !!ThreeDimArray methodsFor: 'accessors' stamp: 'joejohnston 11/3/2013 13:28'!list	^ list.! !!ThreeDimArray methodsFor: 'accessors' stamp: 'joejohnston 11/3/2013 13:40'!list: aCollection	list := aCollection.! !!ThreeDimArray methodsFor: 'accessors' stamp: 'joejohnston 11/2/2013 16:05'!xDimension	^xDim.! !!ThreeDimArray methodsFor: 'accessors' stamp: 'joejohnston 11/2/2013 16:05'!yDimension	^yDim.! !!ThreeDimArray methodsFor: 'accessors' stamp: 'joejohnston 11/2/2013 16:05'!zDimension	^zDim.! !!ThreeDimArray methodsFor: 'setters' stamp: 'joejohnston 11/2/2013 15:48'!dimesnions: anArray	xDim := anArray at: 1.	yDim := anArray at: 2.	zDim := anArray at: 3.! !!ThreeDimArray methodsFor: 'private' stamp: 'joejohnston 11/2/2013 16:06'!x: aNumber	xDim := aNumber.! !!ThreeDimArray methodsFor: 'private' stamp: 'joejohnston 11/2/2013 16:06'!y: aNumber	yDim := aNumber.! !!ThreeDimArray methodsFor: 'private' stamp: 'joejohnston 11/2/2013 16:06'!z: aNumber	zDim := aNumber.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ThreeDimArray class	instanceVariableNames: ''!!ThreeDimArray class methodsFor: 'instance-creation' stamp: 'joejohnston 11/3/2013 13:41'!newWith: xNum with: yNum with: zNum	^ (self new: xNum)		x: xNum;		y: yNum;		z: zNum;		list: OrderedCollection new;		setUpArrays.! !Object subclass: #COSC374Assign1	instanceVariableNames: 'floor'	classVariableNames: ''	poolDictionaries: ''	category: 'Joe-Projects'!Object subclass: #Encrypter	instanceVariableNames: 'alphabet vigenereTableu polybiasSquare cipherType'	classVariableNames: ''	poolDictionaries: ''	category: 'Joe-Projects'!!Encrypter commentStamp: '<historical>' prior: 0!An Encrypter is an object with various encryption and decryption protocols.Instance Variables!!Encrypter methodsFor: 'analyze' stamp: 'joejohnston 9/19/2013 15:33'!frequencyAnalysisOn: aString	| answer |	aString = ''		ifTrue: [ ^ self. ].	answer := OrderedCollection new.	self alphabet do: [ :letter | answer add: letter copy -> (aString instancesOf: letter). ].	^ answer.! !!Encrypter methodsFor: 'analyze' stamp: 'joejohnston 9/19/2013 19:56'!indexOfCoincidenceIn: aString	| count length total convertedString |	aString isNil		ifTrue: [ ^ self. ].	convertedString := aString asUppercase onlyLetters.	length := convertedString size asFloat.	total := 0.0.	self alphabet		do: [ :char | 			count := (convertedString instancesOf: char) asFloat.			total := total + (count * (count - 1) / (length * (length - 1))). ].	^ total.! !!Encrypter methodsFor: 'analyze' stamp: 'jj 9/23/2013 20:05'!indexesOf: t1 in: t2 	| t3 t4 |	t2 = ''		ifTrue: [^ self].	t3 := OrderedCollection new.	t4 := 1.	t2 asUppercase onlyLetters		do: [:t6 | 			t1 = t6				ifTrue: [t3 add: t4].			t4 := t4 + 1].	^ t1 -> t3! !!Encrypter methodsFor: 'accessor' stamp: 'joejohnston 9/19/2013 15:03'!alphabet	^alphabet ! !!Encrypter methodsFor: 'accessor' stamp: 'jj 9/24/2013 00:15'!polybiusSquare	polybiasSquare ifNil: [ self setUpPolybiusSquare ].	^polybiasSquare.! !!Encrypter methodsFor: 'accessor' stamp: 'jj 9/23/2013 20:29'!vigenereTableu	^vigenereTableu .! !!Encrypter methodsFor: 'helper' stamp: 'joejohnston 11/24/2013 21:51'!decryptRSACipher: c withD: d andN: n	"the plaintext message = the ciphertext(C)  (C^ d)%n"	^(c raisedTo: d)%n! !!Encrypter methodsFor: 'helper' stamp: 'joejohnston 11/24/2013 21:45'!encryptRSAMessage: m withE: e andN: n	"the ciphertext (C) = (M^e)%n"	^(m raisedTo: e)%n! !!Encrypter methodsFor: 'helper' stamp: 'jj 9/24/2013 00:38'!getPolybiusNumberFor: aChar	aChar asUppercase = $J		ifTrue: [ ^ '14'. ].	1 to: 5 do: [ :i | 		| index |		index := (self polybiusSquare at: i) indexOf: aChar asUppercase.		index > 0			ifTrue: [ ^ i asString , index asString. ]. ].	^Error.! !!Encrypter methodsFor: 'helper' stamp: 'joejohnston 9/19/2013 15:02'!initialize	alphabet := 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.! !!Encrypter methodsFor: 'helper' stamp: 'joejohnston 10/7/2013 08:53'!parseTextIntoPhrases: aString	| start index sent |	index := 1.	start := 1.	sent := OrderedCollection new.	aString		do: [ :char | 			(((char = $. or: [ char = $?. ]) or: [ char = $!!. ]) or:[ char = $,])				ifTrue: [ 					sent add: (aString copyFrom: start + 1 to: index).					start := index + 1. ].			index := index + 1. ].	^ sent.! !!Encrypter methodsFor: 'helper' stamp: 'joejohnston 10/7/2013 08:53'!parseTextIntoSentences: aString	| start index sent |	index := 1.	start := 1.	sent := OrderedCollection new.	aString		do: [ :char | 			((char = $. or: [ char = $?. ]) or: [ char = $!!. ])				ifTrue: [ 					sent add: (aString copyFrom: start + 1 to: index).					start := index + 1. ].			index := index + 1. ].	^ sent.! !!Encrypter methodsFor: 'helper' stamp: 'jj 9/24/2013 00:22'!setUpPolybiusSquare	|alpha|	alpha :='ABCDEFGHIKLMNOPQRSTUVWXYZ'.	polybiasSquare := OrderedCollection new.	polybiasSquare add: (alpha copyFrom: 1 to: 5).	polybiasSquare add: (alpha copyFrom: 6 to: 10).	polybiasSquare add: (alpha copyFrom: 11 to: 15).	polybiasSquare add: (alpha copyFrom: 16 to: 20).	polybiasSquare add: (alpha copyFrom: 21 to: 25).! !!Encrypter methodsFor: 'helper' stamp: 'jj 9/23/2013 20:27'!setUpVigenereTableu	vigenereTableu ifNotNil: [ ^ self. ].	vigenereTableu := OrderedCollection new.	0 to: 25 do: [ :i | vigenereTableu add: (self caesarShift: i on: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'). ].! !!Encrypter methodsFor: 'helper' stamp: 'joejohnston 11/2/2013 13:48'!solutionsFor: aSetOfNumbers mod: setwisePrimes	||	setwisePrimes isSetWisePrime ifFalse: [ ^self ].	setwisePrimes size = aSetOfNumbers size ifFalse: [ ^self ].! !!Encrypter methodsFor: 'encryption protocol' stamp: 'jj 9/23/2013 20:15'!caesarShift: aNumber on: aString	| answer index |	index := 1.	answer := aString onlyLetters.	answer copy		do: [ :t6 | 			| t7 |			t7 := t6 asUppercase asInteger + aNumber.			(t7 > $A asInteger and: [ t7 < $Z asInteger. ])				ifTrue: [ answer at: index put: (t6 asUppercase asInteger + aNumber) asCharacter. ]				ifFalse: [ 					t7 > $Z asInteger						ifTrue: [ answer at: index put: (t7 - 26) asCharacter. ].					t7 = $Z asInteger						ifTrue: [ answer at: index put: $Z. ].					t7 < $A asInteger						ifTrue: [ answer at: index put: (t7 + 26) asCharacter. ].					t7 = $A asInteger						ifTrue: [ answer at: index put: $A. ]. ].			index := index + 1. ].	^ answer.! !!Encrypter methodsFor: 'encryption protocol' stamp: 'jj 9/23/2013 20:07'!columnarTranspositionLength: aNumber on: aString	| index table answer convertedString |	index := 1.	table := OrderedCollection new.	convertedString := aString asUppercase onlyLetters.	[ index < convertedString size ]		whileTrue: [ 			index + (aNumber - 1) <= aString size				ifTrue: [ table add: (convertedString copyFrom: index to: index + aNumber - 1) ]				ifFalse: [ table add: (convertedString copyFrom: index to: aString size) ].			index := index + aNumber ].	answer := ''.	1 to: aNumber do: [ :i | 		table			do: [ :row | 				i <= row size					ifTrue: [ answer := answer , (row at: i) asString ] ] ].	^ answer! !!Encrypter methodsFor: 'encryption protocol' stamp: 'jj 9/24/2013 00:05'!decryptVigenereCipherUsing: aKeyString on: aMessageString	| answer pos index |	aMessageString ifNil: [ ^ self. ].	aKeyString ifNil: [ ^ aMessageString. ].	answer := aMessageString onlyLetters asUppercase.	self setUpVigenereTableu.	pos := 1.	index := 1.	answer copy		do: [ :char | 			| x y |			x := self vigenereTableu at: (alphabet indexOf: (aKeyString asUppercase at: pos)).			y := x indexOf: (aMessageString asUppercase at: index).			answer at: index put: (self vigenereTableu at: y) first.			pos := pos + 1.			pos > aKeyString size				ifTrue: [ pos := 1. ].			index := index + 1. ].	^ answer.! !!Encrypter methodsFor: 'encryption protocol' stamp: 'jj 9/24/2013 00:39'!encryptPolybiusOn: aString	| answer |	answer := ''.	aString asUppercase onlyLetters  do: [ :char | answer := answer , (self getPolybiusNumberFor: char). ].	^ answer.! !!Encrypter methodsFor: 'encryption protocol' stamp: 'jj 9/23/2013 21:23'!rotation13On: aString	| aToM nToZ answer convertedSTring |	convertedSTring := aString onlyLetters asUppercase.	answer := ''.	aToM := 'ABCDEFGHIJKLM'.	nToZ := 'NOPQRSTUVWXYZ'.	1 to: convertedSTring size do: [ :i | 		| letter |		letter := convertedSTring at: i.		(aToM includes: letter)			ifTrue: [ answer := answer , (nToZ at: (aToM indexOf: letter)) asString. ].		(nToZ includes: letter)			ifTrue: [ answer := answer , (aToM at: (nToZ indexOf: letter)) asString. ]. ].	^ answer.! !!Encrypter methodsFor: 'encryption protocol' stamp: 'jj 9/23/2013 21:32'!vigenereCipherUsing: aNumber on: aString	| answer pos index |	aString ifNil: [ ^ self. ].	aNumber ifNil: [ ^ aString. ].	answer := aString onlyLetters asUppercase.	self setUpVigenereTableu.	pos := 1.	index := 1.	answer copy		do: [ :char | 			| x y |			x := self vigenereTableu at: (alphabet indexOf: (aNumber asUppercase at: pos)).			y := alphabet indexOf: char.			answer at: index put: (x at: y).			pos := pos + 1.			pos > aNumber size				ifTrue: [ pos := 1. ].			index := index + 1. ].	^ answer.	"needs decrypting code..."! !!Encrypter methodsFor: 'checksum' stamp: 'joejohnston 10/7/2013 08:54'!findFromText: aString phraseWithChecksum: aNumber	| phrases |	phrases := self parseTextIntoPhrases:  aString.	phrases		do: [ :phrase | 			(aNumber =( self simpleChecksumOn: phrase))				ifTrue: [ ^ phrase ] ].	^ 'None Found'! !!Encrypter methodsFor: 'checksum' stamp: 'joejohnston 10/7/2013 08:54'!findFromText: aString phrasesWithChecksum: aNumber	| phrases answers|	answers := OrderedCollection new.	phrases := self parseTextIntoPhrases:  aString.	phrases		do: [ :phrase | 			(aNumber =( self simpleChecksumOn: phrase))				ifTrue: [ answers add: phrase ] ].	^ answers.! !!Encrypter methodsFor: 'checksum' stamp: 'joejohnston 10/7/2013 08:42'!simpleChecksumOn: aString	| sum answer convertedString |	convertedString := aString asLowercase.	sum := 0.	convertedString do: [ :each | sum := sum + each asInteger ].	answer := sum bitString.	^ (answer copyFrom: answer size - 7 to: answer size) fromBinary.! !Object subclass: #ChineseRemainderCube	instanceVariableNames: 'coordSet primeSet primeProduct fulcrum cube listBySolution listByX list ByY listByZ'	classVariableNames: ''	poolDictionaries: ''	category: 'Joe-Projects'!!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 11:53'!coordSet	^coordSet! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 12:14'!coordSet: anArray	1 to: anArray size do: [ :i | self coordSet at: i put: (anArray at: i). ].! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 15:43'!cube	^cube.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 16:01'!fillCubeAndList	list := SortedCollection new.	1 to: (self primeSet at: 1) do: [ :x | 		1 to: (self primeSet at: 2) do: [ :y | 			1 to: (self primeSet at: 3) do: [ :z | 				| solution |				solution := self solutionFor: x for: y for: z.				cube					atX: x					atY: y					atZ: z					put: solution.				list add: solution -> (Array with: x with: y with: z). ]. ]. ].	^ listBySolution.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 15:40'!firstFiveSolutions	| first answers |	first := self fulcrum.	[ first > self primeProduct. ] whileTrue: [ first := first - self primeProduct. ].	answers := Array new: 5.	answers at: 1 put: first.	1 to: 4 do: [ :i | answers at: i + 1 put: first + (self primeProduct * i). ].	^ answers.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 15:42'!firstNSolutionsN: aNumber	| first answers |	first := self fulcrum.	[ first > self primeProduct. ] whileTrue: [ first := first - self primeProduct. ].	answers := Array new: aNumber.	answers at: 1 put: first.	1 to: aNumber - 1 do: [ :i | answers at: i + 1 put: first + (self primeProduct * i). ].	^ answers.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/3/2013 11:03'!firstSolution	| first |	first := self fulcrum.	[ first > self primeProduct. ] whileTrue: [ first := first - self primeProduct. ].	^ first.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/3/2013 12:44'!fulcrum	^ fulcrum ifNil: [ self setUpFulcrum. ].! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 11:58'!initialize	coordSet := Array new: 3.	primeSet := Array new: 3.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 16:02'!list	^list  .! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 12:02'!primeProduct	^primeProduct  ifNil: [ primeProduct := primeSet product].	! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 12:03'!primeProduct: aNumber	primeProduct := aNumber .	! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 11:54'!primeSet	^primeSet.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 17:14'!primeSet: anArray	anArray isSetWisePrime		ifFalse: [ ^ self. ].	1 to: anArray size do: [ :i | self primeSet at: i put: (anArray at: i). ].	cube := ThreeDimArray newWith: anArray first with: anArray second with: anArray third.	self primeProduct: anArray product.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/3/2013 12:44'!setUpFulcrum	^ fulcrum := (self solveForGroup: 1) + (self solveForGroup: 2) + (self solveForGroup: 3).! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/2/2013 13:13'!solutionDisplayString	^ 'Any positive integer ' , self fulcrum asString , ' +- ' , self primeSet product asString.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 08:50'!solutionFor: xNum for: yNum for: zNum	self coordSet: (Array with: xNum with: yNum with: zNum).	self setUpFulcrum.	^ self firstSolution.! !!ChineseRemainderCube methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/3/2013 12:38'!solveForGroup: aNumber	| product count temp |	aNumber > 3		ifTrue: [ ^ self. ].	product := (self primeSet copyWithout: (self primeSet at: aNumber)) product.	temp := product.	count := 1.	[ temp % (self primeSet at: aNumber) = ((self coordSet at: aNumber) % (self primeSet at: aNumber)). ]		whileFalse: [ 			temp := product * count.			count := count + 1. ].	^ temp.! !WAComponent subclass: #EncrypterFrontEnd	instanceVariableNames: 'encrypter cipherText message cipherType key shift'	classVariableNames: ''	poolDictionaries: ''	category: 'Joe-Projects'!!EncrypterFrontEnd commentStamp: '<historical>' prior: 0!An EncrypterFrontEnd is the html front end for the Encrypter class.Instance Variables	cipherText:		<Object>	encrypter:		<Object>	message:		<Object>cipherText	- xxxxxencrypter	- xxxxxmessage	- xxxxx!!EncrypterFrontEnd methodsFor: 'as yet unclassified' stamp: 'joejohnston 10/7/2013 13:25'!encryptVigenere	|key plainText|	plainText := self request: 'Enter your message: '.	key := self request: 'Enter your encryption key: ' .	^ self encrypter vigenereCipherUsing: key on: plainText.! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 16:06'!cipherText	^cipherText .! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 16:37'!cipherText: aString	cipherText := aString.! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 16:23'!cipherType	cipherType ifNil: [ self cipherType: #shift ].	^cipherType .	! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 16:22'!cipherType: aSymbol	cipherType := aSymbol .! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 16:41'!encrypt	self cipherType isNil		ifTrue: [ ^ self. ].	self cipherType = #vigenere		ifTrue: [ self cipherText: (self encrypter vigenereCipherUsing: self key on: self message). ].	self cipherType = #shift		ifTrue: [ self cipherText: (self encrypter caesarShift: self shift on: self message). ].	self cipherType = #colTrans		ifTrue: [ self cipherText: (self encrypter columnarTranspositionLength: self shift on: self message). ].	self cipherType = #ROT13		ifTrue: [ self cipherText: (self encrypter rotation13On: self message). ].! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 13:25'!encrypter	^ encrypter.! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 16:03'!key	key ifNil: [self key: 'one'].	^key.! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 16:01'!key: aString	key := aString.! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 16:05'!message	message ifNil: [ self message: '' ].	^message.! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 16:04'!message: aString	message := aString.! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 16:03'!shift	shift ifNil: [ self shift: 0 ].	^ shift.! !!EncrypterFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 10/7/2013 16:03'!shift: aNumber	shift := aNumber .! !!EncrypterFrontEnd methodsFor: 'initialization' stamp: 'joejohnston 10/7/2013 16:06'!initialize	encrypter := Encrypter new.	cipherText := ''.	message := ''.	super initialize.! !!EncrypterFrontEnd methodsFor: 'rendering' stamp: 'joejohnston 10/7/2013 16:43'!renderContentOn: html	html heading: 'Time to encrypt some stuff!!'.	html text: 'Plain Text: '.	html textArea  		callback: [:value| self message: value  ];		value: self message.	html break.	html text: 'Select your cipher: '.	html select 		list: #(#vigenere #shift #colTrans #ROT13);		selected: self cipherType.	html text: 'Shift: '.	html textInput		callback: [ :aNum| self shift: aNum ];		value: self shift .	html break.	html submitButton on: #encrypt of: self.	html break.	html text: 'Cipher text: '.	html textArea		with: self cipherText .	! !!EncrypterFrontEnd methodsFor: 'hooks' stamp: 'joejohnston 10/7/2013 13:03'!style 	^'h1 {text-align: center;}'.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EncrypterFrontEnd class	instanceVariableNames: ''!!EncrypterFrontEnd class methodsFor: 'as yet unclassified' stamp: 'joejohnston 10/7/2013 11:16'!initialize	WAAdmin register: EncrypterFrontEnd asApplicationAt: 'encrypter'.! !WAComponent subclass: #ChineseRemainderCubeFrontEnd	instanceVariableNames: 'cRCube coordinates primeSet isValid cubeFilled'	classVariableNames: ''	poolDictionaries: ''	category: 'Joe-Projects'!!ChineseRemainderCubeFrontEnd methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 17:30'!fillCubeAndList	self isValid ifFalse: [ ^self ].	cRCube primeSet: self primeSet.	cRCube fillCubeAndList .	cubeFilled := true.	! !!ChineseRemainderCubeFrontEnd methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 15:08'!renderGridsOn: html	self cubeFilled		ifFalse: [ ^ self. ].	1 to: self zCoord do: [ :z | |offset|		offset := (z*5) + 100.		html			table			id: ('table',z asString) asSymbol ;			class: '';			style: (self stylePositionLeft: offset  Top: offset );			with: [ 1 to: self yCoord do: [ :y | 					html tableRow: [ 1 to: self xCoord do: [ :x | 							html tableData: (cRCube cube atX: x atY: y atZ: z) asString. ]. ]. ]. ]. ].! !!ChineseRemainderCubeFrontEnd methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 17:26'!renderInputsOn: html	html div		class: 'control';		with: [ 					html text: 'X: '.					html textInput on: #xCoord of: self.					html text: 'Y: '.					html textInput on: #yCoord of: self.					html text: 'Z: '.					html textInput on: #zCoord of: self.					html submitButton						on: #fillCubeAndList of: self;						with: 'Save '. 					self renderSelectorsOn: html].! !!ChineseRemainderCubeFrontEnd methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 15:05'!stylePositionLeft: xCoord Top: yCoord 		^'position: absolute; 	left: ',xCoord asString,'px; 	top: ',yCoord asString,'px;'! !!ChineseRemainderCubeFrontEnd methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 17:31'!xCoord	^ primeSet at: 1.! !!ChineseRemainderCubeFrontEnd methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 17:32'!xCoord: aString	aString asInteger ifNil: [ ^ self. ].	self primeSet at: 1 put: aString asInteger.! !!ChineseRemainderCubeFrontEnd methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 17:32'!yCoord	^ primeSet at: 2.! !!ChineseRemainderCubeFrontEnd methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 17:28'!yCoord: aString	aString asInteger ifNil: [ ^ self. ].	self primeSet at: 2 put: aString asInteger.! !!ChineseRemainderCubeFrontEnd methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 17:32'!zCoord	^ primeSet at: 3.! !!ChineseRemainderCubeFrontEnd methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 17:28'!zCoord: aString	aString asInteger ifNil: [ ^ self. ].	self primeSet at: 3 put: aString asInteger.! !!ChineseRemainderCubeFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 11/9/2013 11:26'!coordinates	^coordinates ! !!ChineseRemainderCubeFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 11/9/2013 17:05'!cubeFilled	^cubeFilled ifNil: [ false ].! !!ChineseRemainderCubeFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 11/23/2013 12:47'!isValid	(self xCoord  isNil or: [ self yCoord  isNil or: [ self zCoord  isNil ] ]) ifTrue: [ ^false ].	self primeSet isSetWisePrime ifFalse: [ ^false ].	^ isValid ifNil: [ ^ true. ].! !!ChineseRemainderCubeFrontEnd methodsFor: 'accessing' stamp: 'joejohnston 11/9/2013 11:26'!primeSet	^primeSet! !!ChineseRemainderCubeFrontEnd methodsFor: 'initialization' stamp: 'joejohnston 11/9/2013 17:02'!initialize	cRCube  := ChineseRemainderCube  new.	coordinates := Array new: 3.	primeSet := Array new: 3.	super initialize.! !!ChineseRemainderCubeFrontEnd methodsFor: 'rendering' stamp: 'joejohnston 11/28/2013 17:26'!cubeList	^ cRCube list ifNotNil: [ :list|  list asSortedCollection sortBlock: [ :a :b | a key < b key. ].] ! !!ChineseRemainderCubeFrontEnd methodsFor: 'rendering' stamp: 'joejohnston 11/24/2013 10:22'!renderButtonsOn: html	html div		class: 'blue-block';		with: [ 					html submitButton						on: #fillCubeAndList of: self;						with: 'Save '.					html break. ].! !!ChineseRemainderCubeFrontEnd methodsFor: 'rendering' stamp: 'joejohnston 11/28/2013 17:27'!renderContentOn: html	self renderHeadingOn: html.	html		form: [ 			self renderInputsOn: html.].	self renderGridsOn: html.! !!ChineseRemainderCubeFrontEnd methodsFor: 'rendering' stamp: 'joejohnston 11/28/2013 15:10'!renderHeadingOn: html	html div		class: 'blue-block';		class: 'pageTitle';		with: [ 					html heading						level3;						with: 'Chinese Remainder Theorem Cubed'.					html break. ].! !!ChineseRemainderCubeFrontEnd methodsFor: 'rendering' stamp: 'joejohnston 11/28/2013 17:38'!renderSelectorsOn: html	self cubeFilled		ifFalse: [ ^ self. ].	html text: 'Results'.	html select 		list: self cubeList;		callback: [ :value| html javascript alert: value ]! !!ChineseRemainderCubeFrontEnd methodsFor: 'rendering' stamp: 'joejohnston 11/28/2013 16:03'!style	^'	body { background-color: #27344C; }	.blue-block{		width: 500px;		height: 50px;		-moz-border-radius: 10px;		border-radius: 10px;		text-align: center; 		background-color: #85ADFF; 		}	th, td 		{ 			position: relative;			border-radius: 5px;   		 	-moz-border-radius:5px;    			-webkit-border-radius:5px;			border: 1px solid black;			background-color: #85ADFF; 		}	.control{		position: fixed;		bottom: 10px;		border-radius: 5px;		background-color: #5C85FF;   		 -moz-border-radius:5px;    		-webkit-border-radius:5px;		height: 50px;		width: 100%;	}	.pageTitle{		position:fixed;		right:-10px;		top: -10px;	}	'! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ChineseRemainderCubeFrontEnd class	instanceVariableNames: ''!!ChineseRemainderCubeFrontEnd class methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 09:50'!initialize	WAAdmin register: ChineseRemainderCubeFrontEnd  asApplicationAt: 'cRCube'.! !WAComponent subclass: #JQueryTestNotes	instanceVariableNames: 'xLimit yLimit zLimit'	classVariableNames: ''	poolDictionaries: ''	category: 'Joe-Projects'!!JQueryTestNotes methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 09:11'!CSSPositionBoxX: xCoord y: yCoord	^ 'top: ' , yCoord asString , 'px; left: ' , xCoord asString , 'px;'.! !!JQueryTestNotes methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 10:59'!jQHideAll: className   On: html	html anchor		onclick: (html jQuery: className)! !!JQueryTestNotes methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 11:16'!renderContentOn: html	self renderLayersOn:  html.	self renderLayerControlsOn: html.! !!JQueryTestNotes methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 10:16'!renderGridOn: html	1 to: 20 do: [ :x | 		1 to: 20 do: [ :y | 			| divName |			divName := 'gridBox' , x asString , y asString.			html anchor				onClick:						((html jQuery: divName asSymbol)								fadeOut: 1 seconds;								fadeIn: 1 seconds);				with: [ 							self								renderSquareWithId: divName								xPos: x								yPos: y								on: html. ]. ]. ].! !!JQueryTestNotes methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 12:25'!renderGridWithLayer: zAxis On: html	1 to: 20 do: [ :x | 		1 to: 20 do: [ :y | 			| divName xOffset yOffset |			yOffset := y * 23 + (zAxis * 15).			xOffset := x * 23 + (zAxis * 15).			divName := 'gridBox' , x asString , y asString , 'layer' , zAxis asString.			html anchor				onClick:						((html jQuery: divName asSymbol)								fadeOut: 1 seconds;								fadeIn: 1 seconds);				with: [ 							html div								id: divName;								class: #box;								class: #blueBox;								style: (self CSSPositionBoxX: xOffset y: yOffset). ]. ]. ].! !!JQueryTestNotes methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 12:30'!renderLayerControlsOn: html		html anchor			style: 'position: absolute; top: 50px; left: 900px;';			onClick: ((html jQuery: 'div.box') hide);			with: 'hide you fools'.		html anchor			style: 'position: absolute; top: 65px; left: 900px;';			onClick: ((html jQuery: 'div.layer1') children show);			with: 'bring one back'.		html anchor			style: 'position: absolute; top: 80px; left: 900px;';			onClick: ((html jQuery: 'div.box ') show);			with: 'bring all back'.! !!JQueryTestNotes methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 12:26'!renderLayersOn: html	1 to: 5 do: [ :z | 		html div			class: ('layer' , z asString) asSymbol;			with: [ self renderGridWithLayer: z On: html. ]. ].! !!JQueryTestNotes methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 09:41'!renderSquareWithId: divName xPos: x yPos: y on: html	^ html div		id: divName;		class: #box;		class: #blueBox;		style: (self CSSPositionBoxX: 23 * x y: 23 * y).! !!JQueryTestNotes methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/28/2013 10:54'!style	^'	.control{		position: absolute;		border-radius: 5px;		border-style: solid;		border-width: 1px;		width: 30px;		height: 10px;	}	.box { 		position: absolute;		border-radius: 5px;		border-style: solid;		border-width: 1px;		width: 20px;		height: 20px;		}	.redBox { 		background-color: #FF8080;	 }	.blueBox { 		background-color: #85ADFF;	 }	'! !Object subclass: #Assignments	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe-Projects'!Notification subclass: #NotSetwisePrimeNotification	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Joe-Projects'!!NotSetwisePrimeNotification methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 12:29'!isResumable 	^true! !!NotSetwisePrimeNotification methodsFor: 'as yet unclassified' stamp: 'joejohnston 11/9/2013 12:29'!promptString	^'Chosen values are not setwise prime.'! !EncrypterFrontEnd initialize!ChineseRemainderCubeFrontEnd initialize!'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 29 November 2013 at 6:28:20 pm'!!Collection methodsFor: '*Joe-Projects' stamp: 'joejohnston 10/30/2013 07:41'!product	| answer |	self isEmpty		ifTrue: [ ^ self. ].	answer := 1.	self		do: [ :each | 			each = 0				ifTrue: [ ^ 0. ].			answer := answer * each. ].	^ answer.	"self assert: #(3 4 5 6) product = 360.self assert: #(3 4 0 6) product = 0."! !'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 29 November 2013 at 6:28:20 pm'!!Collection methodsFor: '*Joe-Projects' stamp: 'joejohnston 11/2/2013 13:48'!isSetWisePrime	self size < 1		ifTrue: [ ^ false. ].	self		do: [ :current | 			(self copyWithout: current)				do: [ :num | 					(current relativelyPrimeTo: num)						ifFalse: [ ^ false. ]. ]. ].	^ true.	"self assert: (OrderedCollection with: 2 with: 3  with: 5 ) setWisePrime = true.self assert: (OrderedCollection with: 2 with: 3  with: 6 ) setWisePrime = false."! !'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 29 November 2013 at 6:28:20 pm'!!String methodsFor: '*Joe-Projects' stamp: 'joejohnston 9/19/2013 15:21'!instancesOf: aCharacter	| count |	count := 0.	self		do: [ :char | 			aCharacter = char				ifTrue: [ count := count + 1. ]. ].	^ count.! !'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 29 November 2013 at 6:28:20 pm'!!String methodsFor: '*Joe-Projects' stamp: 'jj 9/24/2013 00:51'!instancesOfSubstring: aString	| count |	count := 0.	1 to: self size do: [ :i | 		i + (aString size - 1) <= self size			ifTrue: [ 				(self copyFrom: i to: i + (aString size - 1)) = aString					ifTrue: [ count := count + 1. ]. ]. ].	^ count.! !'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 29 November 2013 at 6:28:20 pm'!!Integer methodsFor: '*Joe-Projects' stamp: 'joejohnston 10/21/2013 07:37'!coPrimeTo: aNumber	^ (self gcd: aNumber) = 1.! !'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 29 November 2013 at 6:28:20 pm'!!Integer methodsFor: '*Joe-Projects' stamp: 'joejohnston 10/21/2013 07:03'!factorial	^ self = 1		ifTrue: [ self. ]		ifFalse: [ self * (self - 1) factorial. ].! !'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 29 November 2013 at 6:28:20 pm'!!Integer methodsFor: '*Joe-Projects' stamp: 'joejohnston 10/21/2013 07:38'!relativelyPrimeTo: aNumber	^ (self gcd: aNumber) = 1.! !'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 29 November 2013 at 6:28:20 pm'!!Integer methodsFor: '*Joe-Projects' stamp: 'joejohnston 11/24/2013 20:29'!phi	"bruteforce implementation of phi"	| count |	self < 0		ifTrue: [ ^ 0. ].	count := 0.	1 to: self do: [ :each | 		(self coPrimeTo: each)			ifTrue: [ count := count + 1. ]. ].	^ count.	"	self assert: 12 phi = 4.	"! !'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 29 November 2013 at 6:28:20 pm'!!Integer methodsFor: '*Joe-Projects' stamp: 'joejohnston 11/24/2013 21:31'!findDRelativeTo: phiN	| dees |	dees := 1.	[true]		whileTrue: [ 			dees * self % phiN = 1				ifTrue: [ ^ dees. ].			dees := dees + 1. ].! !'From Pharo2.0 of 7 March 2013 [Latest update: #20619] on 29 November 2013 at 6:28:20 pm'!!Integer methodsFor: '*Joe-Projects' stamp: 'joejohnston 11/24/2013 21:24'!findE	7 to: self do: [ :each | 		(self relativelyPrimeTo: each)			ifTrue: [ ^ each. ]. ].! !